tutaj nic nowego, to co z labów 1...
> docker pull mongo:4.4.6        <=== ta wersja działa ze środowiskiem bez AVX
> docker build -t backend:latest -t backend:2.2.0 .
> docker build -t frontend:latest -t frontend:2.2.0 .

przechodzimy do naszego namespaceu i uruchamiamy deployment, serwisy i inne zabawki na klastrze
(manifesty YAMLowe są w folderze controllers):
> kubectl config set-context --current --namespace=fiszkilab2
> kubectl apply -f controllers/

no i tutaj zaczyna się zabawa bo minikube to środowisko głównie do pracy lokalnej, a tutaj postawione
jest to na zdalnym serwerze, więc niezbyt da się bezpośrednio uzyskać dostęp do usług udostępnianych
przez nasze aplikacje w klastrze. Żeby jako tako to działało trzeba trzymać otwarty
tunel SSH między hostem (tutaj ubuntu na VM) a minikubowym klastrem z włączonym forwardowaniem tego portu:
> minikube service fiszki-backend-nodeport --url -n fiszkilab2
> ssh -i ~/.minikube/machines/minikube/id_rsa docker@$(minikube ip) -L 30080:0.0.0.0:30080

### UPDATE
lepiej działa to:
> kubectl port-forward deployment/backend-deployment 30080:8000

wtedy możemy uzyskać dostęp z poziomu hosta do usług po localhoście, ale dalej nie mamy dostępu do nich
z maszyny zdalnej. Żeby zaczęło działać trzeba zrobić kolejne forwardowanie, tym razem między hostem (serwerem)
a lokalną maszyną. Tutaj zrobił to dla mnie VS Code ale ręcznie też można.



a jako ciekawostka, jeśli akurat szczęście nie dopisze i zabraknie miejsca na dysku podczas instalacji i/lub pierwszego
uruchomienia minikuba, i przy starcie wyrzuca błędy o kluczach, SSH albo certach to trzeba zrobić tak:
> minikube delete
> rm -Rf ~/.minikube/certs